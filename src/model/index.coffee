
###
# The Mother of All Models in this project.
###


class Model

	###
	# construction functions
	###

	###
		~Options~

		frets : Number
		strings: Number
		tuning: Array<Number>
		interval:
			notation: Array<String>
			maxIndex: Number
		scale:
			values: Array<Number>
			root: Number
		selector: Function (Note) => String
	###
	constructor: (args, @events) ->
		# contains the note objects
		@notes = [[]]
		# notation is used to make the integer notation (interval value) "pretty".
		# Other information is derived from it as well.
		@notation = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B']
		# root of the scale
		@root = 1
		# tuning of the instrument, defaults to standard guitar tuning.
		@tuning = [28, 33, 38, 43, 47, 52]
		@scale = undefined
		# the total number of values in the note system. some other systems such
		# as the Maqam have a different scale length (the octave is divided in 24 parts
		# instead of 12 for the Maqam).
		@scaleLength = @notation.length
		# number of strings on the instrument.
		@strings = 6
		# number of frets on the instrument.
		@frets = 16
		# the interval values are generated by repeating 1 to scaleLength a number
		# of times defined by the maxIndex
		@maxIndex = 8
		# And finally we build the whole thing by using the set method which will
		# parse all of the arguments properly.
		@set(args)

	# This will simply fill the notes array with a fresh coat of Note instances
	# based on its current state.
	fill: ->
		@notes = []
		for fret in [0..@frets]
			@notes[fret] = []
			for string in [1..@strings]
				@notes[fret][string-1] = new Note(fret, string)

	# This will handle the rebuilding of the interval-related data, but unlike
	# the original this doesn't take care of the arguments parsing.
	buildInterval: ->
		if @tuning.length != @strings
			throw 'Tuning is invalid for the number of strings given.'
		ln = (@scaleLength * (@maxIndex + 1)) - 1
		intervals = [0..ln]
			.map (i) =>
				f = i + 1
				index = Math.floor(i / @scaleLength)
				intervalValue = f - (index * @scaleLength)

				value: intervalValue
				index: index
				freqId: f
				notation: @notation[intervalValue - 1]

		# I can now slap it on the notes
		@forEach (note, fret, string) =>
			#console.log('interval', intervals[@tuning[string - 1] + fret])
			interval = intervals[@tuning[string - 1] + fret]
			for key of interval
				note.interval[key] = interval[key]

	# This will set up the shifted interval value for building the scale.
	buildRootedValue: ->
		@forEach (note, fret, string) =>
			note.interval.shift = note.interval.value - @root + 1
			if note.interval.shift < 1
				note.interval.shift += @scaleLength

	buildScale: ->
		degree = undefined
		scale = [1..@scaleLength].map (i) => @scale.indexOf(i) + 1

		@forEach (note, fret, string) =>
			if degree = scale[note.interval.shift-1]
				note.interval.degree = degree
			else
				note.interval.degree = undefined

	###
		~Options~

		frets : Number
		strings: Number
		tuning: Array<Number>
		interval:
			notation: Array<String>
			maxIndex: Number
		scale:
			values: Array<Number>
			root: Number
	###
	set: (args) ->
		if args == undefined
			throw 'Oye, forgot something? I need an options object.'

		# start by changing the state of the "settings" on the model.

		if args.strings then @strings = args.strings
		if args.frets then @frets = args.frets
		if args.tuning then @tuning = @asJSArray(args.tuning)
		if args.interval
			i = args.interval
			if i.notation
				@notation = @asJSArray(i.notation)
				# we can derive the scale length of the note system by taking it
				# from the number of notation values we have in there.
				@scaleLength = @notation.length
			if i.maxIndex then @maxIndex = i.maxIndex
		if args.scale
			s = args.scale
			if s.values then @scale = @asJSArray(s.values)
			if s.root then @root = s.root

		# Figure out what to rebuild

		# We dont need to look into it more than that, we're going to have to fill
		# it with new notes.
		fill = args.strings || args.frets || !@notes[0][0]
		buildInterval = args.tuning || args.interval || fill
		buildRootedValue = buildInterval || (args.scale && args.scale.root)
		buildScale = args.scale || (buildRootedValue && @scale)

		if fill then @fill()
		if buildInterval then @buildInterval()
		if buildRootedValue then @buildRootedValue()
		if buildScale then @buildScale()

		if fill || buildInterval || buildRootedValue || buildScale
			@events.broadcast('modelchange')

	# this is a helper function to process array arguments. data can be in the
	# for of a csv or json, as well as a regular array object.
	asJSArray: (arr) ->
		if typeof arr == 'string'
			# smells like JSON
			if arr[0] == '['
				JSON.parse(arr)
			else if arr.indexOf(',') != -1
				arr
					.split(',')
					.map (val) ->
						if isNaN(val)
							throw 'Invalid array input.'
						else Number(val)
			else
				throw 'Could not parse array argument'
		else
			arr

	###
	# Traversing functions
	###

	forEach: (traversor) ->
		for fretArr, fret in @notes
			for note, string in fretArr
				if traversor(note, fret, string+1) == false
					return

	find: (traversor) ->
		result = undefined
		@forEach (note, fret, string) ->
			if traversor(note, fret, string) == true
				result = note
				return false
		result
